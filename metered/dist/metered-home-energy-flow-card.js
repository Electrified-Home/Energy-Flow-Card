(function(){"use strict";function C(){return{schema:[{name:"grid_entity",label:"Grid",required:!0,selector:{entity:{domain:"sensor",device_class:"power"}}},{name:"grid_name",selector:{entity_name:{}},context:{entity:"grid_entity"}},{name:"grid_icon",selector:{icon:{}},context:{icon_entity:"grid_entity"}},{name:"grid_min",label:"Grid Min (W)",selector:{number:{mode:"box"}}},{name:"grid_max",label:"Grid Max (W)",selector:{number:{mode:"box"}}},{name:"grid_tap_action",label:"Grid Tap Action",selector:{"ui-action":{}}},{name:"grid_hold_action",label:"Grid Hold Action",selector:{"ui-action":{}}},{name:"load_entity",label:"Load",required:!0,selector:{entity:{domain:"sensor",device_class:"power"}}},{name:"load_name",selector:{entity_name:{}},context:{entity:"load_entity"}},{name:"load_icon",selector:{icon:{}},context:{icon_entity:"load_entity"}},{name:"load_max",label:"Load Max (W)",selector:{number:{mode:"box"}}},{name:"load_tap_action",label:"Load Tap Action",selector:{"ui-action":{}}},{name:"load_hold_action",label:"Load Hold Action",selector:{"ui-action":{}}},{name:"production_entity",label:"Production",required:!0,selector:{entity:{domain:"sensor",device_class:"power"}}},{name:"production_name",selector:{entity_name:{}},context:{entity:"production_entity"}},{name:"production_icon",selector:{icon:{}},context:{icon_entity:"production_entity"}},{name:"production_max",label:"Production Max (W)",selector:{number:{mode:"box"}}},{name:"production_tap_action",label:"Production Tap Action",selector:{"ui-action":{}}},{name:"production_hold_action",label:"Production Hold Action",selector:{"ui-action":{}}},{name:"battery_entity",label:"Battery",required:!0,selector:{entity:{domain:"sensor",device_class:"power"}}},{name:"battery_name",selector:{entity_name:{}},context:{entity:"battery_entity"}},{name:"battery_icon",selector:{icon:{}},context:{icon_entity:"battery_entity"}},{name:"battery_min",label:"Battery Min (W)",selector:{number:{mode:"box"}}},{name:"battery_max",label:"Battery Max (W)",selector:{number:{mode:"box"}}},{name:"battery_tap_action",label:"Battery Tap Action",selector:{"ui-action":{}}},{name:"battery_hold_action",label:"Battery Hold Action",selector:{"ui-action":{}}},{name:"battery_soc_entity",label:"Battery SOC (%) Entity",selector:{entity:{domain:"sensor"}}},{name:"invert_battery_data",label:"Invert Battery Data",selector:{boolean:{}}},{name:"invert_battery_view",label:"Invert Battery View",selector:{boolean:{}}},{name:"show_plus",label:"Show + Sign",selector:{boolean:{}}}]}}function T(c){if(c.load)return c;const t=o=>{const r=c[`${o}_entity`];if(!r)return;const a={entity:r},d=c[`${o}_name`],h=c[`${o}_icon`],l=c[`${o}_min`],m=c[`${o}_max`],u=c[`${o}_tap_action`],f=c[`${o}_hold_action`];return d!==void 0&&(a.name=d),h!==void 0&&(a.icon=h),l!==void 0&&(a.min=l),m!==void 0&&(a.max=m),u!==void 0&&(a.tap=u),f!==void 0&&(a.hold=f),a},e=t("load"),i=t("grid"),s=t("production"),n=t("battery");if(n){const o=c.battery_soc_entity,r=c.invert_battery_data,a=c.invert_battery_view,d=c.show_plus;o!==void 0&&(n.soc_entity=o),(r!==void 0||a!==void 0)&&(n.invert={data:r!==void 0?r:n.invert?.data,view:a!==void 0?a:n.invert?.view}),d!==void 0&&(n.showPlus=d)}return e?{load:e,grid:i,production:s,battery:n}:c}function E(c){const t=Math.max(0,c.production),e=c.grid,i=c.battery,s=Math.max(0,c.load),n={productionToLoad:0,productionToBattery:0,productionToGrid:0,gridToLoad:0,gridToBattery:0,batteryToLoad:0};let o=t,r=s;if(o>0&&r>0&&(n.productionToLoad=Math.min(o,r),o-=n.productionToLoad,r-=n.productionToLoad),i<0&&o>0&&(n.productionToBattery=Math.min(o,Math.abs(i)),o-=n.productionToBattery),i>0&&r>0&&(n.batteryToLoad=Math.min(i,r),r-=n.batteryToLoad),r>0&&e>0&&(n.gridToLoad=Math.min(e,r),r-=n.gridToLoad),i<0&&e>10){const a=Math.abs(i)-n.productionToBattery;a>1&&(n.gridToBattery=Math.min(e-n.gridToLoad,a))}return e<-10&&(n.productionToGrid=Math.abs(e)),n}function F(c,t,e,i){const s=c[e];return s?s.name?s.name:s.entity&&t?.states[s.entity]&&t.states[s.entity].attributes.friendly_name||i:i}function L(c,t,e,i){const s=c[e];return s?s.icon?s.icon:s.entity&&t?.states[s.entity]&&t.states[s.entity].attributes.icon||i:i}class v{constructor(t,e,i,s,n,o,r,a,d=!1,h=!1,l,m,u){this.id=t,this._value=e,this.min=i,this.max=s,this.bidirectional=n,this.label=o,this.icon=r,this.units=a,this._invertView=d,this.showPlus=h,this.tapAction=l,this.entityId=m,this.fireEventCallback=u,this.element=null,this._needle=null,this._ghostNeedle=null,this.radius=50,this.boxWidth=120,this.boxHeight=135,this.boxRadius=16,this.centerX=this.boxWidth/2,this.centerY=this.radius+25,this.offsetX=-this.centerX,this.offsetY=-this.centerY,this.needleState={target:0,current:0,ghost:0},this._lastAnimationTime=null,this._animationFrameId=null,this._updateNeedleAngle()}get value(){return this._value}set value(t){if(this._value!==t&&(this._value=t,this._updateNeedleAngle(),this.element)){const e=this.element.querySelector(`#value-${this.id}`);e&&(e.textContent=this._formatValueText()),this.updateDimming()}}get invertView(){return this._invertView}set invertView(t){if(this._invertView!==t&&(this._invertView=t,this._updateNeedleAngle(),this.element)){const e=this.element.querySelector(`#value-${this.id}`);e&&(e.textContent=this._formatValueText())}}get displayValue(){return this._invertView?-this._value:this._value}_formatValueText(){const t=this.displayValue,e=t.toFixed(0);return t<0?e+" ":t>0&&this.showPlus?"+"+e+" ":e}_updateNeedleAngle(){let t,e;const i=this.displayValue;if(this.bidirectional){const s=this.max-this.min;t=Math.min(Math.max((i-this.min)/s,0),1),e=180-t*180}else t=Math.min(Math.max(i/this.max,0),1),e=180-t*180;this.needleState.target=e}updateDimming(){if(!this.element)return;const t=this.element.querySelector(`#dimmer-${this.id}`);if(t){const e=Math.abs(this.value)<.5;t.setAttribute("opacity",e?"0.3":"0")}}startAnimation(){if(this._animationFrameId)return;const t=e=>{this._lastAnimationTime||(this._lastAnimationTime=e);const i=e-this._lastAnimationTime;if(this._lastAnimationTime=e,!this.element){this._animationFrameId=null;return}const s=this.radius-5,n=Math.min(i/150,1);this.needleState.current+=(this.needleState.target-this.needleState.current)*n;const o=Math.min(i/400,1);this.needleState.ghost+=(this.needleState.current-this.needleState.ghost)*o;const r=10;if(this.needleState.ghost<this.needleState.current-r?this.needleState.ghost=this.needleState.current-r:this.needleState.ghost>this.needleState.current+r&&(this.needleState.ghost=this.needleState.current+r),!this._needle&&this.element&&(this._needle=this.element.querySelector(`#needle-${this.id}`),this._ghostNeedle=this.element.querySelector(`#ghost-needle-${this.id}`)),this._needle){const a=this.needleState.current*Math.PI/180,d=this.centerX+s*Math.cos(a),h=this.centerY-s*Math.sin(a);this._needle.setAttribute("x2",String(d)),this._needle.setAttribute("y2",String(h))}if(this._ghostNeedle){const a=this.needleState.ghost*Math.PI/180,d=this.centerX+s*Math.cos(a),h=this.centerY-s*Math.sin(a);this._ghostNeedle.setAttribute("x2",String(d)),this._ghostNeedle.setAttribute("y2",String(h))}this._animationFrameId=requestAnimationFrame(t)};this._animationFrameId=requestAnimationFrame(t)}stopAnimation(){this._animationFrameId&&(cancelAnimationFrame(this._animationFrameId),this._animationFrameId=null,this._lastAnimationTime=null),this._needle=null,this._ghostNeedle=null}_handleTapAction(){if(!this.fireEventCallback)return;const t=this.tapAction||{action:"more-info"};switch(t.action||"more-info"){case"more-info":const i=t.entity||this.entityId;i&&this.fireEventCallback("hass-more-info",{entityId:i});break;case"navigate":t.path&&(history.pushState(null,"",t.path),this.fireEventCallback("location-changed",{replace:!1}));break;case"url":t.path&&window.open(t.path);break;case"toggle":this.entityId&&this.fireEventCallback("call-service",{domain:"homeassistant",service:"toggle",service_data:{entity_id:this.entityId}});break;case"call-service":if(t.service){const[s,n]=t.service.split(".");this.fireEventCallback("call-service",{domain:s,service:n,service_data:t.service_data||{},target:t.target})}break}}createElement(){const t=this.displayValue;let e,i;if(this.bidirectional){const _=this.max-this.min;e=Math.min(Math.max((t-this.min)/_,0),1),i=180-e*180}else e=Math.min(Math.max(t/this.max,0),1),i=180-e*180;this.needleState.target=i,this.needleState.current=i,this.needleState.ghost=i;const n=(this.bidirectional?[this.min,0,this.max]:[0,this.max/2,this.max]).map(_=>{const A=(180-(this.bidirectional?(_-this.min)/(this.max-this.min):_/this.max)*180)*Math.PI/180,P=this.radius,k=this.radius-8,D=this.centerX+P*Math.cos(A),N=this.centerY-P*Math.sin(A),X=this.centerX+k*Math.cos(A),B=this.centerY-k*Math.sin(A);return`<line x1="${D}" y1="${N}" x2="${X}" y2="${B}" stroke="rgb(160, 160, 160)" stroke-width="2" />`}).join(""),a=(180-(this.bidirectional?(0-this.min)/(this.max-this.min):0)*180)*Math.PI/180,d=this.centerX,h=this.centerY,l=this.centerX+this.radius*Math.cos(a),m=this.centerY-this.radius*Math.sin(a),u=`<line x1="${d}" y1="${h}" x2="${l}" y2="${m}" stroke="rgb(100, 100, 100)" stroke-width="2" />`,f=i*Math.PI/180,y=this.radius-5,g=this.centerX+y*Math.cos(f),p=this.centerY-y*Math.sin(f),w=this.centerY+5,x=this.centerY+this.radius*.5,z=this.centerY+this.radius*.7,q=`
      <g transform="translate(${this.offsetX}, ${this.offsetY})">
        <defs>
          <clipPath id="clip-${this.id}-local">
            <rect x="0" y="0" width="${this.boxWidth}" height="${w+2}" />
          </clipPath>
        </defs>
        
        <rect x="0" y="0" width="${this.boxWidth}" height="${this.boxHeight}" rx="${this.boxRadius}" ry="${this.boxRadius}" fill="rgb(40, 40, 40)" filter="url(#drop-shadow)" />
        
        <g clip-path="url(#clip-${this.id}-local)">
          <circle cx="${this.centerX}" cy="${this.centerY}" r="${this.radius}" fill="rgb(70, 70, 70)" />
          ${u}
        </g>
        
        ${n}
        
        <circle cx="${this.centerX}" cy="${this.centerY}" r="${this.radius}" fill="none" stroke="rgb(160, 160, 160)" stroke-width="2" />
        
        <text x="${this.centerX}" y="15" text-anchor="middle" font-size="12" fill="rgb(255, 255, 255)" font-weight="500">${this.label}</text>
        
        <!-- Icon rendered via foreignObject (for extraction source) -->
        <foreignObject id="icon-source-${this.id}" x="${this.centerX-18}" y="${this.centerY-42}" width="36" height="36">
          <div xmlns="http://www.w3.org/1999/xhtml" style="width: 36px; height: 36px;">
            <ha-icon icon="${this.icon}" style="--mdc-icon-size: 36px; color: rgb(160, 160, 160);"></ha-icon>
          </div>
        </foreignObject>
        
        <!-- Icon rendered as native SVG path (populated after extraction, will overlay) -->
        <g id="icon-display-${this.id}" transform="translate(${this.centerX-18}, ${this.centerY-42}) scale(1.5)">
          <!-- Path will be inserted here by _extractIconPaths -->
        </g>
        
        <line id="ghost-needle-${this.id}" x1="${this.centerX}" y1="${this.centerY}" x2="${g}" y2="${p}" stroke="rgb(255, 255, 255)" stroke-width="4" stroke-linecap="round" opacity="0.3" />
        
        <line id="needle-${this.id}" x1="${this.centerX}" y1="${this.centerY}" x2="${g}" y2="${p}" stroke="rgb(255, 255, 255)" stroke-width="4" stroke-linecap="round" />
        
        <circle cx="${this.centerX}" cy="${this.centerY}" r="5" fill="rgb(255, 255, 255)" />
        
        <text id="value-${this.id}" x="${this.centerX}" y="${x}" text-anchor="middle" font-size="16" fill="rgb(255, 255, 255)" font-weight="600">${this._formatValueText()}</text>
        
        <text x="${this.centerX}" y="${z}" text-anchor="middle" font-size="8" fill="rgb(160, 160, 160)" font-weight="400" letter-spacing="0.5">${this.units}</text>
        
        <rect id="dimmer-${this.id}" x="0" y="0" width="${this.boxWidth}" height="${this.boxHeight}" rx="${this.boxRadius}" ry="${this.boxRadius}" fill="black" opacity="0" pointer-events="none" style="transition: opacity 0.8s ease-in-out;" />
      </g>
    `,$=document.createElementNS("http://www.w3.org/2000/svg","svg");$.innerHTML=q;const b=$.firstElementChild;return this.element=b,(!this.tapAction||this.tapAction.action!=="none")&&(b.style.cursor="pointer",b.addEventListener("click",_=>{this._handleTapAction(),_.stopPropagation()}),b.addEventListener("mouseenter",()=>{b.style.filter="brightness(1.1)"}),b.addEventListener("mouseleave",()=>{b.style.filter=""})),b}}class R{constructor(t,e,i,s,n,o,r,a){this.group=t,this.flowId=e,this.speedMultiplier=r,this.dotsPerFlow=a,this.dots=[],this.dotStates=[],this.pathLength=0;const d=(i.x+s.x)/2,h=(i.y+s.y)/2;this.pathData=`M ${i.x},${i.y} Q ${d},${h} ${s.x},${s.y}`;const{opacity:l,strokeWidth:m,dotRadius:u}=this.calculateStyles(n),f=this.calculateVelocity(n);this.glowPath=document.createElementNS("http://www.w3.org/2000/svg","path"),this.glowPath.setAttribute("d",this.pathData),this.glowPath.setAttribute("class","flow-line"),this.glowPath.setAttribute("stroke",o),this.glowPath.setAttribute("stroke-opacity",String(l*.5)),this.glowPath.setAttribute("stroke-width",String(m*2)),this.glowPath.setAttribute("fill","none"),this.glowPath.setAttribute("stroke-linecap","round"),this.glowPath.setAttribute("style","transition: stroke-opacity 0.5s ease-out, stroke-width 0.5s ease-out;"),this.glowPath.id=`glow-${e}`,this.group.appendChild(this.glowPath),this.mainPath=document.createElementNS("http://www.w3.org/2000/svg","path"),this.mainPath.setAttribute("d",this.pathData),this.mainPath.setAttribute("class","flow-line"),this.mainPath.setAttribute("stroke",o),this.mainPath.setAttribute("stroke-opacity",String(l)),this.mainPath.setAttribute("stroke-width",String(m)),this.mainPath.setAttribute("fill","none"),this.mainPath.setAttribute("stroke-linecap","round"),this.mainPath.setAttribute("style","transition: stroke-opacity 0.5s ease-out, stroke-width 0.5s ease-out;"),this.mainPath.id=`path-${e}`,this.group.appendChild(this.mainPath),this.pathLength=this.mainPath.getTotalLength();for(let y=0;y<this.dotsPerFlow;y++){const g=document.createElementNS("http://www.w3.org/2000/svg","circle");g.setAttribute("class","flow-dot"),g.setAttribute("id",`dot-${e}-${y}`),g.setAttribute("r",String(u)),g.setAttribute("fill",o),g.setAttribute("opacity",String(l)),g.setAttribute("style","transition: opacity 0.5s ease-out, r 0.5s ease-out;"),this.group.appendChild(g),this.dots.push(g);const p=y/this.dotsPerFlow;this.dotStates.push({progress:p,velocity:f});const w=this.mainPath.getPointAtLength(p*this.pathLength);g.setAttribute("cx",String(w.x)),g.setAttribute("cy",String(w.y))}}calculateStyles(t){let e;t<=100?e=.25:t<=200?e=.25+(t-100)/100*.75:e=1;const i=2,s=23.76,n=1e4;let o;if(t<=100)o=i;else{const l=Math.min((t-100)/(n-100),1)*(s-i);o=i+l}const r=2.5,a=3,d=r*(o/i),h=Math.max(d,a);return{opacity:e,strokeWidth:o,dotRadius:h}}calculateVelocity(t){const e=40*(t/1e3)*this.speedMultiplier;return this.pathLength>0?e/this.pathLength:0}update(t,e){const{opacity:i,strokeWidth:s,dotRadius:n}=this.calculateStyles(t),o=this.calculateVelocity(t);this.glowPath.setAttribute("stroke",e),this.glowPath.setAttribute("stroke-opacity",String(i*.5)),this.glowPath.setAttribute("stroke-width",String(s*2)),this.mainPath.setAttribute("stroke",e),this.mainPath.setAttribute("stroke-opacity",String(i)),this.mainPath.setAttribute("stroke-width",String(s)),this.dots.forEach((r,a)=>{r.setAttribute("r",String(n)),r.setAttribute("opacity",String(i)),r.setAttribute("fill",e),this.dotStates[a].velocity=o})}animate(t){this.dotStates.forEach((e,i)=>{if(e.velocity>0){e.progress+=e.velocity*(t/1e3),e.progress>=1&&(e.progress=e.progress%1);try{if(this.pathLength>0){const s=this.mainPath.getPointAtLength(e.progress*this.pathLength);this.dots[i].setAttribute("cx",String(s.x)),this.dots[i].setAttribute("cy",String(s.y))}}catch{}}})}fadeOut(t){this.glowPath.setAttribute("stroke-opacity","0"),this.mainPath.setAttribute("stroke-opacity","0"),this.dots.forEach(e=>e.setAttribute("opacity","0")),setTimeout(t,500)}}class S{constructor(t,e){this.container=t,this.positions=e,this.flowLines=new Map,this.animationFrameId=null,this.lastAnimationTime=null,this.speedMultiplier=.8,this.dotsPerFlow=3,this.animate=()=>{const i=performance.now(),s=this.lastAnimationTime?i-this.lastAnimationTime:0;this.lastAnimationTime=i,this.flowLines.forEach(n=>{n.animate(s)}),this.animationFrameId=requestAnimationFrame(this.animate)}}updateFlows(t){const e=this.container.querySelector("#flow-layer");if(!e)return;const i=0,s=10;this.updateOrCreateFlow(e,"production-to-load",this.positions.production,this.positions.load,t.productionToLoad,"#4caf50",i),this.updateOrCreateFlow(e,"production-to-battery",this.positions.production,this.positions.battery,t.productionToBattery,"#4caf50",i),this.updateOrCreateFlow(e,"battery-to-load",this.positions.battery,this.positions.load,t.batteryToLoad,"#2196f3",s),this.updateOrCreateFlow(e,"grid-to-load",this.positions.grid,this.positions.load,t.gridToLoad,"#f44336",i),this.updateOrCreateFlow(e,"grid-to-battery",this.positions.grid,this.positions.battery,t.gridToBattery,"#f44336",i),this.updateOrCreateFlow(e,"production-to-grid",this.positions.production,this.positions.grid,t.productionToGrid,"#ffeb3b",i)}start(){this.animationFrameId||(this.lastAnimationTime=performance.now(),this.animate())}stop(){this.animationFrameId&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null,this.lastAnimationTime=null)}clear(){this.stop(),this.flowLines.clear();const t=this.container.querySelector("#flow-layer");t&&(t.innerHTML="")}updateOrCreateFlow(t,e,i,s,n,o,r){const a=this.flowLines.get(e);if(n<=r){a&&this.fadeOutFlow(t,e);return}a?a.update(n,o):this.drawFlow(t,e,i,s,n,o)}drawFlow(t,e,i,s,n,o){const r=document.createElementNS("http://www.w3.org/2000/svg","g");r.setAttribute("id",e),t.appendChild(r);const a=new R(r,e,i,s,n,o,this.speedMultiplier,this.dotsPerFlow);this.flowLines.set(e,a)}removeFlow(t,e){const i=t.querySelector(`#${e}`);i&&(i.remove(),this.flowLines.delete(e))}fadeOutFlow(t,e){const i=this.flowLines.get(e);i&&i.fadeOut(()=>{this.removeFlow(t,e)})}}class I{constructor(t,e,i,s,n,o){this.container=t,this.config=e,this.hass=i,this.getDisplayNameCallback=s,this.getIconCallback=n,this.fireEventCallback=o,this.meters=new Map,this.iconsExtracted=!1,this.iconExtractionTimeouts=new Set,this.iconCache=new Map,this.canvasWidth=500,this.canvasHeight=470;const r=5,a=3;this.meterPositions={production:{x:60+r,y:80+a},battery:{x:130+r,y:240+a},grid:{x:60+r,y:400+a},load:{x:360+r,y:240+a}}}setConfig(t){this.config=t}render(t){const{grid:e,load:i,production:s,battery:n,flows:o}=t,r=this.config.grid?.min??-5e3,a=this.config.grid?.max??5e3,d=this.config.load.max??5e3,h=this.config.production?.max??5e3,l=this.config.battery?.min??-5e3,m=this.config.battery?.max??5e3;if(!this.container.querySelector(".energy-flow-svg"))this.iconsExtracted=!1,this.initializeStructure(e,i,s,n,r,a,d,h,l,m),this.iconsExtracted||requestAnimationFrame(()=>{this.extractIconPaths()});else{const u=this.meters.get("production"),f=this.meters.get("battery"),y=this.meters.get("grid"),g=this.meters.get("load");if(u&&(u.value=s),f&&(f.invertView=this.config.battery?.invert?.view??!1,f.value=n),y&&(y.value=e),g&&(g.value=i),!this.flowRenderer){const p=this.container.querySelector(".energy-flow-svg");p&&(this.flowRenderer=new S(p,this.meterPositions),this.flowRenderer.start())}}this.flowRenderer&&this.flowRenderer.updateFlows(o)}stop(){this.flowRenderer&&this.flowRenderer.stop(),this.meters.forEach(t=>t.stopAnimation()),this.iconExtractionTimeouts.forEach(t=>clearTimeout(t)),this.iconExtractionTimeouts.clear()}clear(){this.stop(),this.flowRenderer&&this.flowRenderer.clear()}initializeStructure(t,e,i,s,n,o,r,a,d,h){const l=new v("production",i,0,a,!1,this.getDisplayNameCallback("production","Production"),this.getIconCallback("production","mdi:solar-power"),"WATTS",!1,!1,this.config.production?.tap,this.config.production?.entity,this.fireEventCallback),m=new v("battery",s,d,h,!0,this.getDisplayNameCallback("battery","Battery"),this.getIconCallback("battery","mdi:battery"),"WATTS",this.config.battery?.invert?.view,this.config.battery?.showPlus,this.config.battery?.tap,this.config.battery?.entity,this.fireEventCallback),u=new v("grid",t,n,o,!0,this.getDisplayNameCallback("grid","Grid"),this.getIconCallback("grid","mdi:transmission-tower"),"WATTS",!1,!1,this.config.grid?.tap,this.config.grid?.entity,this.fireEventCallback),f=new v("load",e,0,r,!1,this.getDisplayNameCallback("load","Load"),this.getIconCallback("load","mdi:home-lightning-bolt"),"WATTS",!1,!1,this.config.load.tap,this.config.load.entity,this.fireEventCallback);this.container.innerHTML=`
      <ha-card>
        <style>
          :host {
            display: block;
            width: 100%;
            height: 100%;
          }
          ha-card {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 8px;
            box-sizing: border-box;
            overflow: hidden;
          }
          .svg-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
          }
          svg.energy-flow-svg {
            display: block;
            width: 100%;
            height: 100%;
          }
          .flow-line {
            fill: none;
            stroke-linecap: round;
          }
          .flow-positive { stroke: var(--success-color, #4caf50); }
          .flow-negative { stroke: var(--error-color, #f44336); }
          .flow-dot {
            offset-path: attr(data-path);
            offset-distance: 0%;
            animation: flow-move var(--flow-duration, 2s) linear infinite;
          }
          @keyframes flow-move {
            from { offset-distance: 0%; }
            to { offset-distance: 100%; }
          }
        </style>
        <div class="svg-wrapper">
          <svg class="energy-flow-svg" viewBox="0 0 ${this.canvasWidth} ${this.canvasHeight}" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
            <defs>
              ${this.createMeterDefs()}
            </defs>
            
            <!-- Flow lines layer (behind meters) -->
            <g id="flow-layer"></g>
            
            <!-- Production Meter (top left) -->
            <g id="production-meter" class="meter-group" transform="translate(${this.meterPositions.production.x}, ${this.meterPositions.production.y})"></g>
            
            <!-- Battery Meter (middle left, offset right) -->
            <g id="battery-meter" class="meter-group" transform="translate(${this.meterPositions.battery.x}, ${this.meterPositions.battery.y})"></g>
            
            <!-- Grid Meter (bottom left) -->
            <g id="grid-meter" class="meter-group" transform="translate(${this.meterPositions.grid.x}, ${this.meterPositions.grid.y})"></g>
            
            <!-- Load Meter (right, 2x size) -->
            <g id="load-meter" class="meter-group" transform="translate(${this.meterPositions.load.x}, ${this.meterPositions.load.y}) scale(2)"></g>
          </svg>
        </div>
      </ha-card>
    `,requestAnimationFrame(()=>{const y=this.container.querySelector("#production-meter"),g=this.container.querySelector("#battery-meter"),p=this.container.querySelector("#grid-meter"),w=this.container.querySelector("#load-meter");y&&y.appendChild(l.createElement()),g&&g.appendChild(m.createElement()),p&&p.appendChild(u.createElement()),w&&w.appendChild(f.createElement()),this.meters.set("production",l),this.meters.set("battery",m),this.meters.set("grid",u),this.meters.set("load",f),l.startAnimation(),m.startAnimation(),u.startAnimation(),f.startAnimation(),l.updateDimming(),m.updateDimming(),u.updateDimming(),f.updateDimming();const x=this.container.querySelector(".energy-flow-svg");x&&!this.flowRenderer&&(this.flowRenderer=new S(x,this.meterPositions),this.flowRenderer.start())})}createMeterDefs(){return`
      <!-- Glow filter for flow lines -->
      <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" />
        <feFlood flood-color="currentColor" flood-opacity="0.5" result="flood" />
        <feComposite in="flood" in2="blur" operator="in" result="coloredBlur" />
        <feMerge>
          <feMergeNode in="coloredBlur" />
          <feMergeNode in="SourceGraphic" />
        </feMerge>
      </filter>
      
      <!-- Drop shadow filter for meters -->
      <filter id="drop-shadow" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="3" result="blur" />
        <feOffset in="blur" dx="0" dy="2" result="offsetBlur" />
        <feComponentTransfer in="offsetBlur" result="shadow">
          <feFuncA type="linear" slope="0.4" />
        </feComponentTransfer>
        <feMerge>
          <feMergeNode in="shadow" />
          <feMergeNode in="SourceGraphic" />
        </feMerge>
      </filter>
    `}extractIconPaths(){["production","battery","grid","load"].forEach(async e=>{const i=this.container.querySelector(`#icon-${e}`),s=this.container.querySelector(`#ha-icon-${e}`);if(i&&s){const n=s.getAttribute("icon")||"unknown",o=this.iconCache.get(n);if(o){this.renderIconPath(i,o);return}const r=await this.extractIconPath(s,n);this.renderIconPath(i,r)}}),this.iconsExtracted=!0}async extractIconPath(t,e,i=10){return new Promise(s=>{const n=(o=1,r=i)=>{const a=o===1?0:100*o,d=window.setTimeout(async()=>{try{const h=t.shadowRoot;if(!h){o<r?n(o+1,r):s(null);return}const l=h.querySelector("svg");if(!l){o<r?n(o+1,r):s(null);return}const m=l.querySelector("path");if(m){const u=m.getAttribute("d");u&&this.iconCache&&this.iconCache.set(e,u),s(u)}else o<r?n(o+1,r):s(null)}catch(h){console.error(`Failed to extract icon path for ${e} (attempt ${o}):`,h),o<r?n(o+1,r):s(null)}},a);this.iconExtractionTimeouts.add(d)};n()})}renderIconPath(t,e){if(t.innerHTML="",e){const i=document.createElementNS("http://www.w3.org/2000/svg","path");i.setAttribute("d",e),i.setAttribute("fill","rgb(160, 160, 160)"),i.setAttribute("transform","scale(1)"),t.appendChild(i)}else{const i=document.createElementNS("http://www.w3.org/2000/svg","circle");i.setAttribute("cx","12"),i.setAttribute("cy","12"),i.setAttribute("r","8"),i.setAttribute("fill","rgb(160, 160, 160)"),t.appendChild(i)}}}class Y extends HTMLElement{constructor(){super(),this._resizeObserver=null}static getStubConfig(){return{}}static getConfigForm(){return C()}connectedCallback(){this._resizeObserver=new ResizeObserver(()=>{}),this.parentElement&&this._resizeObserver.observe(this.parentElement),this._resizeObserver.observe(this)}disconnectedCallback(){this._resizeObserver&&(this._resizeObserver.disconnect(),this._resizeObserver=null),this._defaultRenderer&&this._defaultRenderer.stop()}setConfig(t){this._config=T(t),this._renderSafely("setConfig")}set hass(t){this._hass=t,this._renderSafely("hass update")}_renderSafely(t){try{this._render()}catch(e){console.error("[MeteredHomeEnergyFlowCard] render failed during",t,e),this.innerHTML=`
        <ha-card>
          <div style="padding:16px;">
            Metered Home Energy Flow Card failed to render. Check browser console for details.
          </div>
        </ha-card>
      `}}_render(){if(!this._config||!this._hass||!this._config.load)return;const t=this._getEntityState(this._config.grid?.entity),e=this._getEntityState(this._config.load.entity),i=this._getEntityState(this._config.production?.entity),s=this._getEntityState(this._config.battery?.entity),n=parseFloat(t?.state??"0")||0,o=parseFloat(e?.state??"0")||0,r=parseFloat(i?.state??"0")||0;let a=parseFloat(s?.state??"0")||0;this._config.battery?.invert?.data&&(a=-a),this._defaultRenderer?this._defaultRenderer.setConfig(this._config):this._defaultRenderer=new I(this,this._config,this._hass,(h,l)=>F(this._config,this._hass,h,l),(h,l)=>L(this._config,this._hass,h,l),this._fireEvent.bind(this));const d=E({grid:n,production:r,load:o,battery:a});this._defaultRenderer.render({grid:n,load:o,production:r,battery:a,flows:d})}_getEntityState(t){if(t)return this._hass?.states?.[t]}_fireEvent(t,e={}){if(t==="call-service"&&this._hass){this._hass.callService(e.domain,e.service,e.service_data||{},e.target);return}const i=new CustomEvent(t,{detail:e,bubbles:!0,composed:!0});this.dispatchEvent(i)}}const M="metered-home-energy-flow-card";customElements.get(M)?console.info("[MeteredHomeEnergyFlowCard] custom element already defined"):(customElements.define(M,Y),console.info("[MeteredHomeEnergyFlowCard] defined custom element")),window.customCards=window.customCards||[],window.customCards.push({type:"metered-home-energy-flow-card",name:"Metered Home Energy Flow Card",description:"Flow diagram visualization of home energy flows with animated meters"}),window.dispatchEvent(new Event("ll-rebuild"))})();
